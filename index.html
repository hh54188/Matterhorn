<!DOCTYPE html>
<html>
<head>
	<title>Matterhorn</title>
	<script type="text/javascript" src="js/lib/require.js" data-main="js/main"></script>
    <script type="text/javascript">
        var Person = {
            say: function () {
                console.log("Hello");
            }
        }

        function object(O) {
            function F() {};
            F.prototype = O;
            return new F();
        }

        // Object.create 生成一个新的对象
        // 这个对象的prototype对象是create的传入的对象参数
        // Creates a new object with the specified prototype object and properties.
        var person = Object.create(Person);
        var person1 = object(Person);

        console.log(person);
        console.log(person.constructor);

        console.log(person1);
        console.log(person1.constructor);        

        /*  
            // Object.create:
            person <===> {...} <===> Object.create(Person)
                         {...}.__proto__ <===> Person
            
            // object:
            person <===> {...}
                         {...} <===> new F();
                                         F().prototype <==> Person
                                         {...}.__proto__ <==> Person

            返回的那个对象不能凭空生成，又要考虑重写prototype，于是用了中间实例 new F()
        */

        // 对比另一个new时代的经典继承例子
        function Hero() {}
        Hero.prototype.say = function () {}

        function F() {}; 
        F.prototype = Object.create(Hero.prototype);
        F.prototype.constructor = F; // 非常重要，如果没有的话，f.constructor就变成Hero了！
        var f = new F();

        console.log(f);
        console.log(f.constructor);


    </script>
</head>
<body>

</body>
</html>